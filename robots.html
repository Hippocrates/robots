<html>

<style>
div.sidebar {
	position: absolute;
	left: 524px;
	top: 10px;
}
div.player_div {
	min-width: 150px;
	padding: 20px;
	border:1px solid black;
}
</style>
<body>

<span style="display:none;">
   <img id="moon" src="moon.png">
   <img id="star" src="star.png">
   <img id="gear" src="gear.png">
   <img id="saturn" src="saturn.png">
   <img id="warp" src="warp.png">
   <img id="red" src="red.png">
   <img id="blue" src="blue.png">
   <img id="green" src="green.png">
   <img id="yellow" src="yellow.png">
   <img id="grey" src="grey.png">
</span>

<div id="player_list" class="sidebar"></div>

<canvas id="MainCanvas" width="512" height="512" style="border:1px solid #c3c3c3;">
</canvas>

<br>

<span id="game_info"></span>
<br>

<span class="bid solve">
	<span id="timer"></span>  <span id="num_moves" class="solve"></span>
	<br>
</span>

<span class="playing bid solve">
	<input id="bid_input" type="text" class="playing bid"></input>
	<button id="bid" class="playing bid">Bid</button>
	<span id="curr_bid"></span>
	<button id="gentleman" class="playing bid">Skip Round</button>
	<br>
</span>

<span class="playing solving">
	<span id="turn_indicator">Your Turn!<br></span>
	<button id="revert">Revert</button>
	<button id="undo">Undo</button>
	<button id="redo">Redo</button>
	<button id="skip">Give Up</button>
	<br>
</span>

<span class="playing free end">
	<button id="demo">View Optimal</button>
	<button id="reset_robots">Reset Robots</button>
	<button id="next" class="playing free">Next Round</button>
	<br>
</span>

<span class="playing demo">
	<button id="skip_demo" class="player demo">Skip Demo</button>
	<span id="solution_indicator" class="playing demo"></span>
	<br>
</span>


<span class="playing">
	Name: <span id="name"></span>
	<br>
	Score: <span id="score"></span>
	<br>
</span>

<input id="name_input" type="text" class="" ></input>
<button id="join_game" class="observing">Join</button>
<button id="rename_button" class="playing">Rename</button>
<br>

<button id="leave_game" class="playing">Leave</button>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script type="module" src="/util.js"></script>
<script type="module" src="/robots.js"></script>

<script type="module">

import { Point, Direction, strcmp, intdiv, arrayRemove, arrayFind, isAnyOf } from "./util.js";
import { Game, State, Color, Symbol, RobotMove, Goal, solveBoard } from "./robots.js";
import { TILE_SIZE, getMousePos, getCellFromPos, clearCanvas, getSymbolImage, getRobotImage, getColorValue, drawGoal, drawStartPoint, drawBoard } from "./draw.js";

const ROBOT_TWEEN_SPEED = 32.0;
const TIME_SYNC_INTERVAL = 1000 * 60 * 5; // Once every few minutes?

// length of shortest path is sent by message from server
// don't want people cheating...
const QUIET_MODE = false;

let bidInput = document.getElementById('bid_input');
let nameInput = document.getElementById('name_input');
let revertButton = document.getElementById('revert');
let undoButton = document.getElementById('undo');
let redoButton = document.getElementById('redo');
let skipSolveButton = document.getElementById('skip');
let bidButton = document.getElementById('bid');
let joinButton = document.getElementById('join_game');
let leaveButton = document.getElementById('leave_game');
let renameButton = document.getElementById('rename_button');
let nextRoundButton = document.getElementById('next');
let gentlemanButton = document.getElementById('gentleman');
let resetRobotsButton = document.getElementById('reset_robots');
let skipDemoButton = document.getElementById('skip_demo');
let showDemoButton = document.getElementById('demo');
let pendingFocusElement = nameInput;

function getColorValueArrow(color) {
	if (color == Color.Yellow) {
		return "#AAAA22";
	} else if (color == Color.Green) {
		return "#22AA22";
	} else if (color == Color.Red) {
		return "#AA2222";
	} else if (color == Color.Blue) {
		return "#2222AA";
	} else {
		return "#FFFFFF";
	}
}

class ActiveSelection {
	constructor(game) {
		this.game = game;
		this.selectedRobot = null;
		Object.defineProperty(this, 'directionMoves', { 'value': new Array(4) });
	}
	
	setRobot(robotId) {
		this.selectedRobot = robotId;
		if (this.hasSelection()) {
			for (let dir = 0; dir < 4; ++dir) {
				this.directionMoves[dir] = []
				this.game.board.doMove(this.game.getRobotPositions(), this.selectedRobot, dir, this.directionMoves[dir]);
			}
		}
	}
	
	getMoveEndpoint(dir) {
		return this.directionMoves[dir][this.directionMoves[dir].length - 1];
	}
	
	hasSelection() {
		return this.selectedRobot != null;
	}
	
	clearSelection() {
		this.selectedRobot = null;
	}
}

class Robot {
	constructor(game, position, color) {
		Object.defineProperty(this, 'color', { 'value': color });
		this.game = game;
		this.positionQueue = [position]
		this.tweenAlpha = 0.0;
	}
	
	moveTo(cell) {
		if (this.positionQueue.length > 0 && this.positionQueue[this.positionQueue.length - 1].equals(cell)) {
			return;
		}
		this.positionQueue.push(cell);
		this.game.robots[this.color] = cell;
	}
	
	warpTo(cell) {
		this.positionQueue = [cell];
		this.game.robots[this.color] = cell;
		this.tweenAlpha = 0.0;
	}
	
	getCell() {
		return this.positionQueue[this.positionQueue.length - 1];
	}
	
	update(deltaTime) {
		if (this.positionQueue.length > 1) {
			let dist = this.positionQueue[0].lInfDist(this.positionQueue[1]);
			this.tweenAlpha = Math.min(this.tweenAlpha + (deltaTime * ROBOT_TWEEN_SPEED) / dist, 1.0);
			
			if (this.tweenAlpha >= 1.0) {
				this.positionQueue.shift();
				this.tweenAlpha = 0.0;
			}
		}
	}
	
	getDrawPosition(offset = new Point(0, 0)) {
		let basePosition;
		if (this.positionQueue.length == 1) {
			basePosition = this.positionQueue[0].mul(TILE_SIZE);
		} else {
			basePosition = this.positionQueue[0].mul(TILE_SIZE * (1 - this.tweenAlpha)).add(this.positionQueue[1].mul(TILE_SIZE * this.tweenAlpha));
		}
		return basePosition.add(offset);
	}
	
	getImage() {
		return getRobotImage(this.color);
	}
	
	getColorValue() {
		return getColorValue(this.color);
	}
	
	draw(canvas, offset = new Point(0, 0)) {
		let ctx = canvas.getContext("2d");
		let pos = this.getDrawPosition(offset);
		ctx.drawImage(this.getImage(), pos.x, pos.y);
	}
}

// Globals
let game = new Game();
let robots = [];

let selection = new ActiveSelection(game);
let canvas = document.getElementById("MainCanvas");
let moveSequence = [];
let redoStack = [];
let moveCount = null;

let demoAvailable = false;
let demoLength = -1;
let arrowSequence = [];

let playerId = null;
let currentSolvingPlayer = null;

let serverTimeDelta = 0;
let serverBidStartTime = null;

let socket = null;

let timeSyncTimeoutId = null;

class MoveArrow {
	static cellHCount = Array(game.board.width * game.board.height).fill(0);
	static cellVCount = Array(game.board.width * game.board.height).fill(0);
	static finalRobotPositions = [];

	constructor(start, end, color, game) {
		this.startPoint = start;
		this.endPoint = end;
		this.color = color;
		this.game = game;
		this.tweenAlpha = 0;

		this.updateCellCount();
		this.dodge = this.findMaxLineCount() - 1;
	}

	static clearCellCounts() {
		MoveArrow.cellHCount = Array(game.board.width * game.board.height).fill(0);
		MoveArrow.cellVCount = Array(game.board.width * game.board.height).fill(0);
	}

	static setFinalPosition(robotID, x, y) {
		MoveArrow.finalRobotPositions[robotID] = new Point(x, y);
	}

	static clearFinalPositions() {
		MoveArrow.finalRobotPositions = [];
	}
	static drawCellCounts() {
		for(let y = 0; y < game.board.height; y++) {
			for(let x = 0; x < game.board.width; x++) {
				let ctx = canvas.getContext("2d");

				let str = Math.max(MoveArrow.cellHCount[y * game.board.height + x], MoveArrow.cellVCount[y * game.board.height + x])
				ctx.fillText(str, (x + 0.5) * TILE_SIZE, (y + 0.5) * TILE_SIZE);
			}
		}
	}

	isCellFull(cell) {
		let result = false;

		if(this.game.board.getCell(cell).getGoal()) {
			result = true;
		}

		for(let i in this.game.robots) {

			if(cell.equals(MoveArrow.finalRobotPositions[i])) {
				result = true;
			}
		}

		return result;
	}

	getDirection() {
		return this.endPoint.sub(this.startPoint).getDirection();
	}

	getCellArray()
	{
		let direction = this.getDirection();

		if (direction == Direction.Left || direction == Direction.Right)
		{
			return MoveArrow.cellHCount;
		}
		else
		{
			return MoveArrow.cellVCount;
		}
	}

	updateCellCount() {
		let currPoint = this.startPoint;
		let direction = Point.fromDirection(this.getDirection());
		let cellArray = this.getCellArray();

		cellArray[currPoint.y * game.board.height + currPoint.x]++;

		do {
			currPoint = currPoint.add(direction);
			cellArray[currPoint.y * game.board.height + currPoint.x]++;
		} while(!currPoint.equals(this.endPoint))
	}

	findMaxLineCount() {
		let currPoint = this.startPoint;
		let cellArray = this.getCellArray();

		let max = cellArray[this.startPoint.y * game.board.height + this.startPoint.x];
		let directionUnit = Point.fromDirection(this.getDirection());

		do {
			currPoint = currPoint.add(directionUnit);
			let curr = cellArray[currPoint.y * game.board.height + currPoint.x];

			if(curr > max) {
				max = curr;
			}
		} while(!currPoint.equals(this.endPoint))

		return max;
	}

	draw(canvas) {
		const ARROW_SIZE = 6;
		const PADDING = 5;
		const LINE_THICKNESS = 1.5;
		const DODGE_WIDTH = 4;

		let ctx = canvas.getContext("2d");
		let direction = this.getDirection();
		let offset = TILE_SIZE / 2;

		let isStartFull = this.isCellFull(this.startPoint);
		let isDestFull = this.isCellFull(this.endPoint);

		let fullStartCellAdjustment = isStartFull ? offset : PADDING;
		let fullDestCellAdjustment = isDestFull ? offset : PADDING;

		// place start and end points in center of tile
		let x1 = this.startPoint.x * TILE_SIZE + offset;
		let y1 = this.startPoint.y * TILE_SIZE + offset;
		let x2 = this.endPoint.x * TILE_SIZE + offset;
		let y2 = this.endPoint.y * TILE_SIZE + offset;

		// shrink arrow length if start or destination cell is full
		x1 = x1 - (fullStartCellAdjustment) * (direction % 2 - 1) * (direction - 1);
		y1 = y1 + (fullStartCellAdjustment) * (direction % 2) * (direction - 2);
		x2 = x2 + (fullDestCellAdjustment) * (direction % 2 - 1) * (direction - 1);
		y2 = y2 - (fullDestCellAdjustment) * (direction % 2) * (direction - 2);

		// displace arrow to the side if cells in the arrow's path already contain arrows
		x1 += DODGE_WIDTH * this.dodge * (direction % 2) * (direction - 2);
		y1 += DODGE_WIDTH * this.dodge * (direction % 2 - 1) * (direction - 1);
		x2 += DODGE_WIDTH * this.dodge * (direction % 2) * (direction - 2);
		y2 += DODGE_WIDTH * this.dodge * (direction % 2 - 1) * (direction - 1);

		// for some nice arrow tweening
		if(direction == Direction.Left || direction == Direction.Right) {
			x2 = x1 + (x2 - x1) * this.tweenAlpha;
		} else {
			y2 = y1 + (y2 - y1) * this.tweenAlpha;
		}

		let arrowAngle = -1 * Math.PI / 2 * direction;

		ctx.strokeStyle = getColorValueArrow(this.color);
		ctx.lineWidth = LINE_THICKNESS;

		// arrow shaft
		ctx.beginPath();
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.stroke();

		// arrow head
		ctx.beginPath();
		ctx.moveTo(x2,y2);
		ctx.lineTo(x2 + Math.cos(arrowAngle + Math.PI / 4) * ARROW_SIZE, y2 - Math.sin(arrowAngle + Math.PI / 4) * ARROW_SIZE);
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(x2,y2);
		ctx.lineTo(x2 + Math.cos(arrowAngle - Math.PI / 4) * ARROW_SIZE, y2 - Math.sin(arrowAngle - Math.PI / 4) * ARROW_SIZE)
		ctx.stroke();
	}

	update(deltaTime) {
		let dist = this.startPoint.lInfDist(this.endPoint);
		this.tweenAlpha = Math.min(this.tweenAlpha + (deltaTime * ROBOT_TWEEN_SPEED) / dist, 1.0);
	}
}

function drawGame(game, canvas, offset = new Point(0, 0)) {
	clearCanvas(canvas);
	drawBoard(game.board, canvas, offset);

	if (game.originalRobotConfig != null) {
		for (let i = 0; i < game.originalRobotConfig.length; ++i) {
			drawStartPoint(game.originalRobotConfig[i], i, canvas, offset);
		}
	}

	for (let i = 0; i < robots.length; ++i) {
		robots[i].draw(canvas, offset);
	}
	
	if (selection.hasSelection()) {
		let ctx = canvas.getContext("2d");
		ctx.fillStyle = robots[selection.selectedRobot].getColorValue();
		ctx.globalAlpha = 0.3;
		let current = robots[selection.selectedRobot].getCell();
		let currentDraw = current.mul(TILE_SIZE).add(offset);
		ctx.fillRect(currentDraw.x, currentDraw.y, TILE_SIZE, TILE_SIZE);
	
		for (let dir = 0; dir < 4; ++dir) {
			current = robots[selection.selectedRobot].getCell();
			for (let segment = 1; segment < selection.directionMoves[dir].length; ++segment) {
				// TODO: will need to cover the entire path (or at least all segments of the path) if we add bumpers
				let extent = selection.directionMoves[dir][segment];
				let delta = selection.directionMoves[dir][segment].sub(selection.directionMoves[dir][segment - 1]);
				delta = Point.fromDirection(delta.getDirection());
				while (!extent.equals(current)) {
					current = current.add(delta);
					currentDraw = current.mul(TILE_SIZE).add(offset);
					ctx.fillRect(currentDraw.x, currentDraw.y, TILE_SIZE, TILE_SIZE);
					
					if (current.x < 0 || current.y < 0 || current.x >= game.board.size.x || current.y >= game.board.size.y) {
						selection.setRobot(selection.selectedRobot);
						break;
					}
				}
			}
		}
		ctx.globalAlpha = 1.0;
	}
	
	if (game.currentGoal != null) {
		drawGoal(game.currentGoal, canvas, game.board.size.mul(TILE_SIZE / 2.0).sub(TILE_SIZE / 2.0, TILE_SIZE / 2.0));
	}
}

function updateUI() {
	if (playerId == null) {
		$('.observing').show();
	} else {
		$('.playing').show();
	}

	let hideStates = State.allValues.filter(s => s != game.state).map(s => "." + State.str(s).toLowerCase());
	
	if (!isClientSolving()) {
		hideStates.push('.solving');
	}
	
	$(hideStates.join(', ')).hide();
	let showState = State.str(game.state).toLowerCase()
	$('.' + showState).show();
	
	if (playerId == null) {
		$('.playing').hide();
	} else {
		$('.observing').hide();
	}

	let timer = document.getElementById('timer');
	if (serverBidStartTime != null) {
		let serverNow = Date.now() + serverTimeDelta;
		let bidTimeElapsed = serverNow - serverBidStartTime;
		if (game.state == State.Bid) {
			let bidTimeLeft = Math.max((game.bidTimeout * 1000) - bidTimeElapsed, 0);
			timer.textContent = epochDeltaToTime(bidTimeLeft);
		} else if (game.state == State.Solve) {
			let bidTimeLeft = Math.max((game.solveTimeout * 1000) - bidTimeElapsed, 0);
			timer.textContent = epochDeltaToTime(bidTimeLeft);
		}
	} else {
		timer.textContent = "";
	}
	
	let numMoves = document.getElementById('num_moves');
	if (game.state == State.Solve && numMoves != null && moveCount != null) {
		numMoves.textContent = moveCount.toString();
	}
	
	if (playerId != null) {	
		revertButton.disabled = !(isClientSolving() && hasUndo());
		undoButton.disabled = !(isClientSolving() && hasUndo());
		redoButton.disabled = !(isClientSolving() && hasRedo());
		
		bidInput.disabled = !canEnterBid();
		bidButton.disabled = !canBid();
		
		let currentBid = game.getBid(playerId);
		let currBidElement = document.getElementById('curr_bid');
		if (currentBid != null) {
			currBidElement.textContent = `Current Bid: ${currentBid.amount}`;
		} else {
			currBidElement.textContent = "";
		}
		
		let player = game.getPlayer(playerId);
		
		gentlemanButton.disabled = player.vote == 'SKIPBID';
		nextRoundButton.disabled = player.vote == 'NEXT';
		skipDemoButton.disabled = player.vote == 'SKIPDEMO';
		showDemoButton.disabled = (player.vote == 'DEMO' || !demoAvailable);
		
		document.getElementById('name').textContent = "" + player.name;
		document.getElementById('score').textContent = "" + player.getScore();
	}
	
	let namingDisabled = !canRename();
	joinButton.disabled = namingDisabled;
	renameButton.disabled = namingDisabled;

	if (pendingFocusElement != null) {
		pendingFocusElement.focus();
		pendingFocusElement = null;
	}
}

function canRename() {
	return nameInput.value.length > 0;
}

function skipSolve() {
	if (socket != null) {
		socket.send(`SKIP_SOLVE`);
	}
}

function voteGentleman() {
	if (socket != null) {
		socket.send(`VOTE SKIPBID`);
	}
}

function voteSkipDemo() {
	if (socket != null) {
		socket.send(`VOTE SKIPDEMO`);
	}
}

function voteNextRound() {
	if (socket != null) {
		socket.send(`VOTE NEXT`);
	}
}

function voteViewOptimal() {
	if (socket != null) {
		socket.send(`VOTE DEMO`);
	}
}

function joinGame() {
	let nameValue = nameInput.value;
	if (nameValue.length > 0) {
		if (socket != null) {
			socket.send(`JOIN_GAME ${nameValue}`);
		} else {
			playerId = game.addPlayer(null, nameValue);
		}
	}
}

function leaveGame() {
	if (playerId != null) {
		game.removePlayer(playerId);
		if (socket != null) {
			socket.send(`LEAVE_GAME ${playerId}`);
		}
		playerId = null;
		pendingFocusElement = nameInput;
	}
}

function tryRename() {
	let nameValue = nameInput.value;
	if (playerId != null && nameValue.length > 0 && nameValue != game.getPlayer(playerId).name) {
		game.renamePlayer(playerId, nameValue);
		if (socket != null) {
			socket.send(`PLAYER_RENAME ${playerId} ${nameValue}`);
		}
	}
}

function canEnterBid() {
	if (game.getState() == State.Bid) {
		let currentBid = game.getBid(playerId);
		return currentBid == null || (game.allowMultipleBids && currentBid.amount > 2);
	}
	return false;
}

function canBid() {
	if (game.getState() == State.Bid) {
		let currentBid = game.getBid(playerId);
		let currentInputBid = getCurrentBidInputValue();
		return currentInputBid > 1 && (currentBid == null || (game.allowMultipleBids && currentInputBid != null && currentInputBid < currentBid.amount));
	}
	return false;
}

function getCurrentBidInputValue() {
	let bidText = bidInput.value;
	if (bidText.length > 0) {
		let asInt = parseInt(bidText);
		return asInt;
	}
	return 0;
}

function executeBid() {
	if (canBid()) {
		let asInt = getCurrentBidInputValue();
		if (asInt > 1) {
			bidInput.value = '';
			if (socket != null) {
				socket.send(`MAKE_BID ${asInt}`);
			} else {
				game.setBid(playerId, asInt);
			}
		}
	}
}

function hasUndo() {
	return isClientSolving() && moveSequence.length > 0;
}

function undoMove() {
	if (!canDoMoves()) {
		return;
	}
	if (hasUndo()) {
		let lastMove = moveSequence.pop();
		robots[lastMove.color].warpTo(lastMove.position);
		redoStack.push(lastMove);
		moveCount = moveSequence.length;
		if (socket != null) {
			socket.send('UNDO_ROBOT');
		}
	}
	updateUI();
}

function hasRedo() {
	return isClientSolving() && redoStack.length > 0;
}

function redoMove() {
	if (!canDoMoves()) {
		return;
	}
	if (hasRedo()) {
		let addMove = redoStack.pop();
		let moveTarget = game.moveRobot(addMove.color, addMove.direction);
		robots[addMove.color].warpTo(moveTarget);
		moveSequence.push(addMove);
		moveCount = moveSequence.length;
		if (socket != null) {
			socket.send('REDO_ROBOT');
		}
	}
	updateUI();
}

function revertMoves() {
	if (!canDoMoves()) {
		return;
	}
	game.resetRobotPositions();
	for (let i = 0; i < robots.length; ++i) {
		robots[i].warpTo(game.robots[i]);
	}
	if (isClientSolving()) {
		redoStack.push(...moveSequence.reverse());
		moveSequence = [];
		moveCount = 0;
	}
	updateUI();
	
	if (socket != null) {
		socket.send('RESET_ROBOTS');
	}
}

function leftPad(v, x) {
	return v.toString().padStart(x, '0');
}

function epochDeltaToTime(deltaTime) {
	let millis = deltaTime % 1000;
	deltaTime = intdiv(deltaTime, 1000);
	let seconds = deltaTime % 60;
	deltaTime = intdiv(deltaTime, 60);
	let minutes = deltaTime;

	return `${minutes}:${leftPad(seconds, 2)}`
}

function canDoMoves() {
	return playerId != null && (isClientSolving() || isAnyOf(game.state, State.Free, State.End));
}

function isClientSolving() {
	return currentSolvingPlayer != null && playerId != null && currentSolvingPlayer == playerId;
}

function doDirectionMove(direction) {
	if (selection.hasSelection()) {
		let target = selection.getMoveEndpoint(direction);
		if (!target.equals(robots[selection.selectedRobot].getCell())) {
			if (game.state == State.Solve) {
				moveSequence.push(new RobotMove(robots[selection.selectedRobot].getCell(), direction, null, robots[selection.selectedRobot].color));
				redoStack = [];
				moveCount = moveSequence.length;
				updateUI();
			}
			socket.send(`MOVE_ROBOT ${selection.selectedRobot} ${direction}`);
			for (let i = 1; i < selection.directionMoves[direction].length; ++i) {
				robots[selection.selectedRobot].moveTo(selection.directionMoves[direction][i]);
			}
			return true;
		}
	}
	return false;
}

canvas.addEventListener('click', function(evt) {
	let mousePos = getMousePos(canvas, evt);
	let cellPos = getCellFromPos(mousePos);
	
	let didAction = false;
	let isFree = game.state == State.Free;
	
	if (canDoMoves()) {
		if (selection.hasSelection()) {
			if (!robots[selection.selectedRobot].getCell().equals(cellPos)) {
				if (isFree && evt.shiftKey) {
					if (arrayFind(game.robots, cellPos) == -1) {
						socket.send(`FREE_MOVE_ROBOT ${selection.selectedRobot} ${cellPos.x} ${cellPos.y}`);
						robots[selection.selectedRobot].moveTo(cellPos);
						didAction = true;
					}
				} else {
					for (let dir = 0; dir < 4; ++dir) {
						let target = selection.getMoveEndpoint(dir);
						if (target.equals(cellPos)) {
							didAction = doDirectionMove(dir);
						}
					}
				}
			}
		}
		
		if (!didAction) {
			selection.clearSelection();
			for (let i = 0; i < robots.length; ++i) {
				if (cellPos.equals(robots[i].getCell())) {
					selection.setRobot(i);
					didAction = true;
					break;
				}
			}
		}
	}
}, false);

window.addEventListener("keydown", function(event) {
	if (event.defaultPrevented) {
		return;
	}
	
	if (isClientSolving()) {
		if (event.key == "z" && event.ctrlKey) {
			undoMove();
		}
		
		if (event.key == "y" && event.ctrlKey) {
			redoMove();
		}
	}
	
	if (canDoMoves()) {
		if (event.key >= '1' && event.key <= '9') {
			let id = parseInt(event.key) - 1;
			if (id < robots.length) {
				selection.setRobot(id);
			}
		}
	
		if (selection.hasSelection()) {
			if (event.key == "ArrowRight" || event.key == 'd') {
				doDirectionMove(Direction.Right);
			}
			if (event.key == "ArrowLeft" || event.key == 'a') {
				doDirectionMove(Direction.Left);
			}
			if (event.key == "ArrowUp" || event.key == 'w') {
				doDirectionMove(Direction.Up);
			}
			if (event.key == "ArrowDown" || event.key == 's') {
				doDirectionMove(Direction.Down);
			}
			if (event.key == "Escape" || event.key == 'x') {
				selection.clearSelection();
			}
		}
	}
	
	//event.preventDefault();
}, true);

function clearMoveArrows() {
	MoveArrow.clearCellCounts();
	MoveArrow.clearFinalPositions();
	arrowSequence = [];
}

let lastLoop = 0;
function loop(timestamp) {
	let deltaTime = (timestamp - lastLoop) / 1000.0;
	lastLoop = timestamp;

	for (let i = 0; i < robots.length; ++i) {
		robots[i].update(deltaTime);
	}
	
	updateUI();
	
	drawGame(game, canvas);

	if(game.state == State.Demo) {
		for(let i in arrowSequence) {
			arrowSequence[i].draw(canvas);
		}
		arrowSequence[arrowSequence.length - 1]?.update(deltaTime);
	}

	window.requestAnimationFrame(loop);
}

function onServerMessageReceived(data) {
	let lines = data.split('\n');
	
	if (lines.length <= 0) {
		return;
	}
	
	for (let i = 0; i < lines.length; ++i) {
		let [command, ...args] = lines[i].split(' ');
		command = command.toUpperCase();
		doServerCommand(command, args);
	}
}

function doServerCommand(command, args) {
	if(!QUIET_MODE)
	{
		console.log(`${command} ${args}`);
	}

	if (command == 'GIVE_TOKENS') {
		processGiveTokens(args);
	} else if (command == 'REJECT_CLIENT') {
		processRejectClient(args);
	} else if (command == 'ASSIGN_PLAYER') {
		processAssignPlayer(args);
	} else if (command == 'NEW_BOARD') {
		processNewBoard(args);
	} else if (command == 'PLAYER_JOINED') {
		processPlayerJoined(args);
	} else if (command == 'PLAYER_LEFT') {
		processPlayerLeft(args)
	} else if (command == 'PLAYER_RENAME') {
		processRenamePlayer(args);
	} else if (command == 'PLAYER_BID') {
		processSetBid(args);
	} else if (command == 'ROBOT_MOVEALL' || command == 'ROBOT_RESET') {
		processRobotReset(args);
		if (command == 'ROBOT_RESET') {
			game.originalRobotConfig = [...game.robots];
		}
	} else if (command == 'ROBOT_MOVE') {
		processRobotMove(args);
	} else if (command == 'SET_STATE') {
		processSetState(args);
	} else if (command == 'TIME_SYNC') {
		processTimeSync(args);
	} else if (command == 'START_TIMER') {
		processStartTimer(args);
	} else if (command == 'START_SOLVE') {
		processStartSolve(args);
	} else if (command == 'PLAYER_VOTE') {
		processPlayerVote(args);
	} else if (command == 'DEMO_READY') {
		demoAvailable = true;
	} else if (command == 'FINAL_POSITION') {
		processFinalPosition(args);
	}
}

function processPlayerVote(args) {
	let playerId = parseInt(args[0]);
	let player = game.getPlayer(playerId);
	player.vote = args[1];

	$(`#${makePlayerDivId(playerId)} > .player_vote`).text(`Vote: ${player.vote}`);
}

function processStartSolve(args) {
	currentSolvingPlayer = parseInt(args[0]);
	serverBidStartTime = parseInt(args[1]);
	moveCount = 0;
	moveSequence = []
	redoStack = []

	updateUI();
}

function processStartTimer(args) {
	serverBidStartTime = parseInt(args[0]);
}

function processTimeSync(args) {
	let timeNow = Date.now();
	let roundTripTime = timeNow - parseInt(args[0]);
	let serverTime = parseInt(args[1]);
	let halfRtt = roundTripTime / 2;
	let serverTimeNow = serverTime + halfRtt;
	
	serverTimeDelta = serverTimeNow - timeNow;

	console.log(`Server Time Delta = ${serverTimeDelta}`);
}

function processGiveTokens(args) {
	let targetPlayerId = parseInt(args[0]);
	let tokens = args.slice(1).map(t => Goal.fromInt(parseInt(t)));
	console.assert(targetPlayerId != Number.NaN);

	game.giveTokens(targetPlayerId, tokens);

	let player = game.getPlayer(targetPlayerId);

	$(`#${makePlayerDivId(targetPlayerId)} > .player_score`).text(`Score: ${player.tokens.length}`);
	updateTokenCount();
}

function processFinalPosition(args) {
	let tok = args.toString().split(",");
	let numPositions = intdiv(tok.length, 3);

	for(let i = 0; i < numPositions; i++) {
		MoveArrow.setFinalPosition(tok[i * 3], tok[i * 3 + 1], tok[i * 3 + 2]);
	}
}

function updateTokenCount() {
	if (game.goalsRemaining.length == 0) {
		let players = game.getPlayers(true);
		$('#game_info').text(`${players[0].name} wins!`);
	} else {
		$('#game_info').text(`Tokens Remaining: ${game.goalsRemaining.length}`);
	}
}

function setWinner(playerId) {
	let player = game.getPlayer(playerId);
	
}

function processNewBoard(args) {
	let numRobots = parseInt(args[0]);
	console.assert(numRobots != Number.NaN);
	let boardSeed = parseInt(args[1]);
	console.assert(boardSeed != Number.NaN);
	
	game.resetGame(numRobots, boardSeed);
	
	robots = [];
	for (let i = 0; i < game.robots.length; ++i) {
		robots.push(new Robot(game, game.robots[i], i));
	}

	updateTokenCount();
}

function processSetState(args) {
	game.state = parseInt(args[0]);
	game.clearVotes();

	$(`.player_vote`).text('');

	if (args.length > 1) {
		if (isAnyOf(game.state, State.Bid, State.Solve, State.Demo, State.Free)) {
			game.currentGoal = Goal.fromInt(parseInt(args[1]));
			moveCount = 0;
			demoLength = -1;
		}
	}
	if (game.state == State.Bid) {
		game.resetBids();
		$('.player_bid').text('');
		demoAvailable = false;
		pendingFocusElement = bidInput;
	}

	if (game.state == State.Demo) {
		demoLength = parseInt(args[2]);
		clearMoveArrows();
		document.getElementById('solution_indicator').textContent = `The computer found: ${demoLength}`;
	}

	selection.clearSelection();
	serverBidStartTime = null;
	currentSolvingPlayer = null;
	moveSequence = []
	redoStack = []
	moveCount = null;
}

function processAssignPlayer(args) {
	playerId = parseInt(args[0]);
	if (game.state == State.Bid) {
		pendingFocusElement = bidInput;
	}
}

function processRejectClient(args) {
	console.log(`Server rejected client: ${args[0]}`);
	socket.close();
}

function makePlayerDivId(playerId) {
	return `Player_${playerId}`;
}

function processPlayerJoined(args) {
	let playerId = game.addPlayer(args[1], parseInt(args[0]));
	let player = game.getPlayer(playerId);

	let playerDiv = document.getElementById('player_list');

	const playerNode = document.createElement("div");
	playerNode.id = makePlayerDivId(player.id);
	playerNode.className = 'player_div';

	const nameNode = document.createElement('span');
	nameNode.textContent = `${player.name}`;
	nameNode.className = 'player_name';
	const scoreNode = document.createElement('span');
	scoreNode.textContent = 'Score: 0';
	scoreNode.className = 'player_score';
	const bidNode = document.createElement('span');
	bidNode.className = 'player_bid';
	const voteNode = document.createElement('span');
	voteNode.className = 'player_vote';

	playerNode.appendChild(nameNode);
	playerNode.appendChild(document.createElement("br"));
	playerNode.appendChild(scoreNode);
	playerNode.appendChild(document.createElement("br"));
	playerNode.appendChild(bidNode);
	playerNode.appendChild(document.createElement("br"));
	playerNode.appendChild(voteNode);

	playerDiv.appendChild(playerNode);
}

function processPlayerLeft(args) {
	let leftId = parseInt(args[0]);
	if (leftId == playerId) {
		playerId = null;
	}
	game.removePlayer(leftId);

	let playerDiv = document.getElementById(makePlayerDivId(leftId));
	if (playerDiv != null) {
		playerDiv.parentNode.removeChild(playerDiv);
	}
}

function processRenamePlayer(args) {
	let playerId = parseInt(args[0]);
	let name = args[1];
	game.renamePlayer(playerId, name);

	$(`#${makePlayerDivId(playerId)} > .player_name`).text(name);
}

function processSetBid(args) {
	let playerId = parseInt(args[0]);
	let bid = parseInt(args[1]);
	let timestamp = parseInt(args[2]);
	if (bid == 0) {
		game.removeBid(playerId);
	} else {
		game.setBid(playerId, bid, timestamp);
	}

	$(`#${makePlayerDivId(playerId)} > .player_bid`).text(`Bid: ${bid}`);
}

function processRobotReset(args) {
	for (let i = 0; i < Math.min(robots.length * 2, args.length); i += 2) {
		let robotId = intdiv(i, 2);
		let dest = new Point(parseInt(args[i]), parseInt(args[i+1]));
		robots[robotId].warpTo(dest);
	}
	selection.clearSelection();
	if (args.length % 2 == 1) {
		moveCount = parseInt(args[args.length - 1]);
	}

	if(game.state == State.Demo) {
		clearMoveArrows();
	}
}

function processRobotMove(args) {
	let robotId = parseInt(args[0]);

	if (game.state == State.Solve) {
		moveCount = parseInt(args[1]);
	}
	
	let moveList = [];

	for (let i = 2; i < args.length; i += 2) {
		let dest = new Point(parseInt(args[i]), parseInt(args[i + 1]));
		moveList.push(dest);
	}

	if (moveList.length > 0 && !moveList[moveList.length - 1].equals(robots[robotId].getCell())) {
		let lastPos = robots[robotId].getCell();
		for (let i = 0; i < moveList.length; ++i) {
			robots[robotId].moveTo(moveList[i]);
			if (game.state == State.Demo) {
				arrowSequence.push(new MoveArrow(lastPos, moveList[i], robotId, game))
			}
			lastPos = moveList[i];
		}
	}

	if (selection.selectedRobot == robotId) {
		selection.setRobot(selection.selectedRobot);
	}

	updateUI();
}

function doTimeSync() {
	if (timeSyncTimeoutId != null) {
		clearTimeout(timeSyncTimeoutId);
	}

	socket.send(`SYNC_TIME ${Date.now()}`);

	timeSyncTimeoutId = setTimeout(doTimeSync, TIME_SYNC_INTERVAL);
}

window.onload = function() {
	// TODO: If this doesn't connect, just leave it in the free state, this allows you to play locally

	let targetServer = window.location.href;
	let protocolPoint = targetServer.search(':')
	let protocol = targetServer.slice(0, protocolPoint);
	let isSecure = protocol == 'https';
	let wsTarget = (isSecure ? 'wss' : 'ws') + targetServer.slice(protocolPoint);
	console.log(wsTarget)
	
	for (let i = 0; i < game.robots.length; ++i) {
		robots.push(new Robot(game, game.robots[i], i));
	}
	
	socket = new WebSocket(wsTarget);

	socket.onopen = function(event) {
		doTimeSync();
	}

	socket.onmessage = function(event) {
		if(!QUIET_MODE)
		{
			console.log(`Message = ${event.data}`);
		}
		onServerMessageReceived(event.data);
	};

	socket.onclose = function(event) {
		if (event.wasClean) {
			console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
		} else {
			// e.g. server process killed or network down
			// event.code is usually 1006 in this case
			console.log('[close] Connection died');
		}
	};

	socket.onerror = function(error) {
		console.log(`[error] ${error.message}`);
	};
};

window.onbeforeunload = function() {
    socket.onclose = function () {}; // disable onclose handler first
    socket.close();
};

bidInput.onkeypress = function(event) { return event.key in ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]; };
bidInput.onkeyup = function(event) {
	if (event.keyCode === 13) {
		// Cancel the default action, if needed
		event.preventDefault();
		// Trigger the bid
		if (canBid()) {
			executeBid();
		}
	}
};

nameInput.onkeyup = function(event) {
	if (event.keyCode === 13) {
		// Cancel the default action, if needed
		event.preventDefault();
		if (canRename()) {
			// Trigger a join or rename
			if (playerId == null) {
				joinGame();
			} else {
				tryRename();
			}
		}
	}
}

function defaultClickLambda(fn) {
	return function(ev) {
		fn();
		ev.preventDefault();
	}
}

revertButton.onclick = revertMoves;
undoButton.onclick = undoMove;
redoButton.onclick = redoMove;
skipSolveButton.onclick = skipSolve;
bidButton.onclick = executeBid;
joinButton.onclick = joinGame;
leaveButton.onclick = leaveGame;
renameButton.onclick = tryRename;
nextRoundButton.onclick = voteNextRound;
gentlemanButton.onclick = voteGentleman;
resetRobotsButton.onclick = revertMoves;
skipDemoButton.onclick = voteSkipDemo;
showDemoButton.onclick = voteViewOptimal;

window.requestAnimationFrame(loop);

// TODO:
// - Demo state: optionally show the best available solution at the end of the round
// - Add a proper random-board generation system
// - Clean up the UI, make it clearer when the state and round transition changes

</script>

</body>
</html>